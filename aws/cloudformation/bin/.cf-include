#!/bin/sh -e

###############################################
# Locl Variables
###############################################
BUILD_STEP=1
LOG_FILE=


###############################################
# Reporting functions
###############################################

#----------------------------------------------
# set_log_file [log file path]
#----------------------------------------------
set_log_file() {
  local TRY_FILE=$1

  [ "[${TRY_FILE}]" = "[]" ] && return 0
  [ -f ${TRY_FILE} ] || return 0
  
  LOG_FILE=${TRY_FILE}
  return 0
}

#----------------------------------------------
# log_output
#----------------------------------------------
log_output() {
  local HAS_LOGFILE=0
  [ "[${LOG_FILE}]" = "[]" ] || HAS_LOGFILE=1

  while read OUTPUT; do
    if [ ${HAS_LOGFILE} -eq 0 ]; then
      echo "${OUTPUT}" >&2
    else
      echo "${OUTPUT}" | tee -a ${LOG_FILE} >&2
    fi
  done <&0
  return 0
}

#----------------------------------------------
# report_output
#----------------------------------------------
report_output() {
  local OUTPUT
  while read OUTPUT; do
    echo "* ${OUTPUT}" | log_output
  done <&0
}

#----------------------------------------------
# report_topic [...message]
#----------------------------------------------
report_topic() {
  [ $# -eq 0 ] && return 0

  cat <<MESSAGE_LIST | log_output

************************************
*
* $@
*
************************************
* $(date '+%D %T')

MESSAGE_LIST

  return 0
}

#----------------------------------------------
# report_error [exit code] [...message]
#----------------------------------------------
report_error() {
  local EXIT_CODE=$1
  [ $# -gt 0 ] && shift 1

  cat <<ERROR_MESSAGE | log_output

!! Error: ${@}

ERROR_MESSAGE

  [ "[${EXIT_CODE}]" = "[]" ] && exit 1
  [ "${EXIT_CODE}" -gt 0 ] >/dev/null 2>&1 && exit ${EXIT_CODE}
  return 0
}

#----------------------------------------------
# report_log [...message]
#----------------------------------------------
report_log() {
  [ $# -eq 0 ] && return 0

  cat <<MESSAGE_LIST | log_output
* $@

MESSAGE_LIST

  return 0
}

#----------------------------------------------
# report_step [...message]
#----------------------------------------------
report_step() {
  [ $# -eq 0 ] && return 0

  cat <<MESSAGE_LIST | log_output

* ${BUILD_STEP}. $@
------------------------------------
** $(date '+%D %T')

MESSAGE_LIST

  BUILD_STEP=$((${BUILD_STEP} + 1))

  return 0
}

###############################################
# Package.json functions
###############################################

#----------------------------------------------
# inspect_package [package.json]
#----------------------------------------------
inspect_package() {
  [ "[$1]" = "[]" ] && return 1

  [ -f "$1" ] || return 2

  return 0
}

#----------------------------------------------
# jq_format
#----------------------------------------------
jq_format() {
  local JQ_RESULT=$(cat)
  [ "[${JQ_RESULT}]" = "[]" ] && echo "null" && return 0
  echo ${JQ_RESULT}
  return 0
}

#----------------------------------------------
# get_package_name [package.json]
#----------------------------------------------
get_package_name() {
  local PACKAGE_FILE=$1

  inspect_package ${PACKAGE_FILE} || return 1

  local DEFAULT_NAME=$(basename $(dirname ${PACKAGE_FILE}))
  local PACKAGE_NAME=$(cat ${PACKAGE_FILE} | jq -r ".name" | jq_format)

  # use default if "name" do not exist
  [ "${PACKAGE_NAME}" = "null" ] && \
    echo ${DEFAULT_NAME} && \
    return 0

  echo "${PACKAGE_NAME}"
  return 0
}

#----------------------------------------------
# get_package_version [package.json]
#----------------------------------------------
get_package_version() {
  local PACKAGE_FILE=$1

  inspect_package ${PACKAGE_FILE} || return 1
  local PACKAGE_VERSION=$(cat ${PACKAGE_FILE} | jq -r ".version" | jq_format)
  local DEFAULT_VERSION="1.0.0"

  [ "${PACKAGE_VERSION}" = "null" ] && \
    echo ${DEFAULT_VERSION} && \
    return 0

  echo "${PACKAGE_VERSION}"
  return 0
}

###############################################
# Layer functions
###############################################

#----------------------------------------------
# layer_remove_packages [package.json]
#----------------------------------------------
layer_remove_packages() {
  local PACKAGE_FILE=$1

  inspect_package ${PACKAGE_FILE} || \
    report_error 1 "Unable to access [package.json]: ${PACKAGE_FILE}."

  local PACKAGE_DIR=$(dirname ${PACKAGE_FILE})
  local CACHE_FILE=${PACKAGE_DIR}/package-cache
  local PACKAGE_SOURCE
  local PACKAGE_NAME

  # read packages
  while read PACKAGE_NAME; do
    PACKAGE_SOURCE=$(cat ${PACKAGE_FILE} | jq -r ".dependencies.\"${PACKAGE_NAME}\"" | jq_format)

    # validate package source
    [ ${PACKAGE_SOURCE} = "null" ] && continue
    echo ${PACKAGE_SOURCE} | grep -q '^file:' || continue

    # remove
    cat ${PACKAGE_FILE} | \
      jq "del(.dependencies.\"${PACKAGE_NAME}\")" > ${CACHE_FILE}

    # replace
    mv -f ${CACHE_FILE} ${PACKAGE_FILE}

done <<PACKAGE_LIST
$(cat ${PACKAGE_FILE} | jq -r '.dependencies | keys[]')
PACKAGE_LIST

  return 0
}

#----------------------------------------------
# layer_rebuild_packages [package.json] [layer directory]
#   - layer directory should be relative to package.json
#----------------------------------------------
layer_rebuild_packages() {
  local PACKAGE_FILE=$1

  # remove layer packages first!
  layer_remove_packages "${PACKAGE_FILE}"

  local PACKAGE_DIR=$(dirname ${PACKAGE_FILE})
  local CACHE_FILE=${PACKAGE_DIR}/package-cache

  local LAYER_ORG_NAME=$(get_package_name ${PACKAGE_FILE})
  local LAYER_VERSION=$(get_package_version ${PACKAGE_FILE})
  local LAYER_DIR=$2
  local FULL_LAYER_DIR=${PACKAGE_DIR}/${LAYER_DIR}

  local LAYER_PACKAGE_DIR
  local PACKAGE_NAME
  local PACKAGE_SOURCE
  local PACKAGE_MANIFEST
  local LAYER_DIR_NAME

  # validate layer directory
  [ "[$2]" = "[]" ] && \
    report_error 1 "Requires [layer directory] parameter."

  [ -d "${FULL_LAYER_DIR}" ] || \
    report_error 1 "[layer directory] not accessible: ${FULL_LAYER_DIR}"

  while read LAYER_DIR_NAME; do
    LAYER_PACKAGE_DIR=${FULL_LAYER_DIR}/${LAYER_DIR_NAME}
    PACKAGE_NAME="@${LAYER_ORG_NAME}/${LAYER_DIR_NAME}"
    PACKAGE_SOURCE="file:${LAYER_DIR}/${LAYER_DIR_NAME}"
    PACKAGE_MANIFEST=${LAYER_PACKAGE_DIR}/package.json

    # validate package directory
    [ -d "${LAYER_PACKAGE_DIR}" ] || continue
    [ -f "${LAYER_PACKAGE_DIR}/index.js" ] || continue

    # create package if do not exist
    if [ ! -f ${PACKAGE_MANIFEST} ]; then
      cat <<PACKAGE_MANIFEST > ${PACKAGE_DIR}/package.json
{
  "name": "${PACKAGE_NAME}",
  "version": "${LAYER_VERSION}",
  "description": "Layer package: ${PACKAGE_NAME}",
  "main": "index.js",
  "private": true,
  "license": "ISC"
}
PACKAGE_MANIFEST

    # update package.json
    else
      cat ${PACKAGE_MANIFEST} | \
        jq ".name = \"${PACKAGE_NAME}\"" | \
        jq ".version = \"${LAYER_VERSION}\"" > ${CACHE_FILE}

      mv -f ${CACHE_FILE} ${PACKAGE_MANIFEST}
    fi

    # update main package manifest
    cat ${PACKAGE_FILE} | \
      jq ".dependencies.\"${PACKAGE_NAME}\" = \"${PACKAGE_SOURCE}\"" > ${CACHE_FILE}

    mv -f ${CACHE_FILE} ${PACKAGE_FILE}

  done <<PACKAGE_LIST
$(ls -1 ${FULL_LAYER_DIR})
PACKAGE_LIST

  return 0
}

###############################################
# S3 bucket
###############################################
#----------------------------------------------
# create_bucket_if [bucket name]
#----------------------------------------------
create_bucket_if() {
  BUCKET_NAME=$1
  [ "[${BUCKET_NAME}]" = "[]" ] && \
    report_error 0 "Requires [bucket name] parameter" &&
    return 1

  # inspect if bucket exist
  aws s3 ls "s3://${BUCKET_NAME}" >/dev/null 2>&1 && return 0

  aws s3 mb "s3://${BUCKET_NAME}" 2>&1 | report_output >/dev/null 2>&1 || return 1

  return 0
}

###############################################
# Cloudformation build functions
###############################################

#----------------------------------------------
# inspect_output_directory [output directory]
#----------------------------------------------
inspect_output_directory() {
  [ "[${1}]" = "[]" ] && return 1
  [ -d "${1}" ] || return 2
  return 0
}

#----------------------------------------------
# get_stack_name
#----------------------------------------------
get_stack_name() {
  basename ${WORKING_DIR}
  return 0
}

#----------------------------------------------
# build_layers [output directory]
#----------------------------------------------
build_layers() {
  ! inspect_output_directory $1 && \
    report_error 0 "Output directory not acessible: $1" && \
    return 1

  local OUTPUT_DIR=$1
  local TARGET_DIR=${OUTPUT_DIR}/layer/nodejs
  local PACKAGE_MANIFEST=${WORKING_DIR}/package.json
  local PACKAGE_MANIFEST_LOCK=${WORKING_DIR}/package-lock.json
  local LAYER_DIR=lambda/layer
  local SOUCE_DIR=${WORKING_DIR}/${LAYER_DIR}

  # cleanup
  rm -Rf ${OUTPUT_DIR}/layer

  # do not build if no lambda/layer directory
  [ -d ${SOUCE_DIR} ] || return 0
  
  # Rebuild source layers
  layer_rebuild_packages \
    ${PACKAGE_MANIFEST} \
    ${LAYER_DIR} || return 1

  # cleanup
  mkdir -p ${TARGET_DIR}
  rm -Rf ${TARGET_DIR}/*

  # create manifest copy
  cp -f ${PACKAGE_MANIFEST} ${TARGET_DIR}/
  [ -f ${PACKAGE_MANIFEST_LOCK} ] && \
    cp -f ${PACKAGE_MANIFEST_LOCK} ${TARGET_DIR}/

  # create layers copy
  cp -Rf ${SOUCE_DIR} ${TARGET_DIR}/lib

  # Rebuild output layers
  layer_rebuild_packages \
    ${TARGET_DIR}/package.json \
    lib || return 1

  # install modules
  cd ${TARGET_DIR}
  npm install -y --production 2>&1 | report_output || return 0
  cd ${WORKING_DIR}

  report_log "Built layer: @$(get_package_name ${PACKAGE_MANIFEST})"

  return 0
}

#----------------------------------------------
# build_lambda [output directory]
#----------------------------------------------
build_lambda() {
  ! inspect_output_directory $1 && \
    report_error 0 "Output directory not acessible: $1" && \
    return 1

  local OUTPUT_DIR=$1
  local TARGET_DIR=${OUTPUT_DIR}/lambda
  local SOURCE_DIR=${WORKING_DIR}/lambda
  local FUNCTION_NAME
  local FUNCTION_DIR

  # cleanup
  rm -Rf ${TARGET_DIR}

  # do not build if no lambda/directory
  if [ ! -d ${SOURCE_DIR} ]; then
    report_log "No Lambda function to process."
    return 0
  fi

  # recreate directory
  mkdir -p ${TARGET_DIR}

  while read FUNCTION_NAME; do
    FUNCTION_DIR=${SOURCE_DIR}/${FUNCTION_NAME}

    # validate
    [ -d ${FUNCTION_DIR} ] || continue
    [ -f ${FUNCTION_DIR}/index.js ] || continue

    # copy to target directory
    cp -Rf ${FUNCTION_DIR} ${TARGET_DIR}/

    report_log "Built lambda function: ${FUNCTION_NAME}"

  done <<FUNCTION_LIST
$(ls -1 ${SOURCE_DIR})
FUNCTION_LIST

  return 0
}

#----------------------------------------------
# build_package [output directory]
#----------------------------------------------
build_package() {
  ! inspect_output_directory $1 && \
    report_error 0 "Output directory not acessible: $1" && \
    return 1

  local OUTPUT_DIR=$1
  local OUTPUT_TEMPLATE_FILE=${OUTPUT_DIR}/cloudformation.yaml
  local STACK_NAME=$(get_stack_name)
  local BUCKET_NAME=${STACK_NAME}-cf-deployments
  local BUCKET_PREFIX=$(date +%Y-%m-%d)
  local DEPLOYMENT_JSON_FILE=${OUTPUT_DIR}/deployment.json

  # create bucket if do not exist
  if ! create_bucket_if ${BUCKET_NAME}; then
    report_error 0 "Unable to create ${BUCKET}"
    return 1
  fi

  # package stack
  report_log "Creating package"
  if ! aws cloudformation package \
        --template-file ${CF_TEMPLATE_FILE} \
        --s3-bucket ${BUCKET_NAME} \
        --s3-prefix ${BUCKET_PREFIX} \
        --output-template-file ${OUTPUT_TEMPLATE_FILE} 2>&1 | report_output; then
    report_error 0 "There were errors packaging your cloudformation template"
    return 1
  fi

  # generate deployment manifest
  cat <<DEPLOYMENT_JSON > ${DEPLOYMENT_JSON_FILE}
{
  "name": "${STACK_NAME}",
  "template": "${OUTPUT_TEMPLATE_FILE}",
  "capabilities": "CAPABILITY_NAMED_IAM",
  "bucket": "${BUCKET_NAME}",
  "bucketPrefix": "${BUCKET_PREFIX}"
}
DEPLOYMENT_JSON

  return 0
}

#----------------------------------------------
# deploy_build [output directory]
#----------------------------------------------
deploy_build() {
  ! inspect_output_directory $1 && \
    report_error 0 "Output directory not acessible: $1" && \
    return 1

  local OUTPUT_DIR=$1
  local DEPLOYMENT_JSON_FILE=${OUTPUT_DIR}/deployment.json

  # must not deploy unless deployment manifest is present
  if [ ! -f ${DEPLOYMENT_JSON_FILE} ]; then
    report_error 0 "Unable to deploy packaged stack $(get_stack_name)"
    return 1
  fi

  local STACK_NAME=$(cat ${DEPLOYMENT_JSON_FILE} | jq -r ".name")
  local TEMPLATE_FILE=$(cat ${DEPLOYMENT_JSON_FILE} | jq -r ".template")

  # must not deploy unless deployment manifest is present
  if [ ! -f ${TEMPLATE_FILE} ]; then
    report_error 0 "Unable to find template file for stack ${STACK_NAME}."
    return 1
  fi

  if ! aws cloudformation deploy \
          --stack-name ${STACK_NAME} \
          --template-file ${TEMPLATE_FILE} \
          --capabilities $(cat ${DEPLOYMENT_JSON_FILE} | jq -r ".capabilities") \
          --s3-bucket $(cat ${DEPLOYMENT_JSON_FILE} | jq -r ".bucket") \
          --s3-prefix $(cat ${DEPLOYMENT_JSON_FILE} | jq -r ".bucketPrefix") 2>&1 | report_output; then
    report_error 0 "Deployment failed. Please run redeploy command again ${REDEPLOY_COMMAND}"
  fi
}


###############################################
# EXPORT variables
###############################################
export TOOLS_DIR=$(dirname $(realpath -m $0))
export WORKING_DIR=$(pwd)

export CF_TEMPLATE_FILE=${WORKING_DIR}/cloudformation.yaml

###############################################
# Initialize
###############################################

# report error
[ -f ${CF_TEMPLATE_FILE} ] || report_error 1 "No cloudformation template found."
